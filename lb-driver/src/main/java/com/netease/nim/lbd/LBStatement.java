package com.netease.nim.lbd;

import java.sql.*;

public class LBStatement implements Statement {

    private final Statement stmt;
    protected LBConnection connection;
    protected boolean closed = false;

    public LBStatement(Statement statement, LBConnection connection) {
        this.stmt = statement;
        this.connection = connection;
    }

    protected void checkOpen() throws SQLException {
    	connection.checkClosed();
        if (closed) {
            throw new SQLException("lb statment is already closed.");
        }
    }

    public boolean execute(String sql) throws SQLException {
        checkOpen();

        try {
            boolean result = stmt.execute(sql);
            dealTransaction(sql);
            return result;
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    protected void dealTransaction(String sql) {
        if (startTransaction(sql) && !connection.isTransactionBegun()) {
            connection.setTransactionBegun(true);
        } else if (endTransaction(sql) && connection.isTransactionBegun()) {
        	connection.setTransactionBegun(false);
        }
    }

    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        checkOpen();

        try {
            boolean result = stmt.execute(sql, autoGeneratedKeys);
            dealTransaction(sql);
            return result;
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        checkOpen();

        try {
            boolean result = stmt.execute(sql, columnIndexes);
            dealTransaction(sql);
            return result;
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public boolean execute(String sql, String[] columnNames) throws SQLException {
        checkOpen();

        try {
            boolean result = stmt.execute(sql, columnNames);
            dealTransaction(sql);
            return result;
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }
    
    public boolean executeUpdate(String sql, boolean throwFatalError) throws SQLException {
        checkOpen();

        try {
        	if (throwFatalError)
        		throw new SQLException("shit", "08003");
            boolean result = stmt.execute(sql);
            dealTransaction(sql);
            return result;
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public ResultSet executeQuery(String sql) throws SQLException {
        checkOpen();

        try {
            ResultSet result = stmt.executeQuery(sql);
            dealTransaction(sql);
            return result;
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int executeUpdate(String sql) throws SQLException {
        checkOpen();

        try {
            int result = stmt.executeUpdate(sql);
            dealTransaction(sql);
            return result;
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        checkOpen();

        try {
            int result = stmt.executeUpdate(sql, autoGeneratedKeys);

            dealTransaction(sql);

            return result;
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        checkOpen();

        try {
            int result = stmt.executeUpdate(sql, columnIndexes);
            dealTransaction(sql);
            return result;
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        checkOpen();

        try {
            int result = stmt.executeUpdate(sql, columnNames);
            dealTransaction(sql);
            return result;
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public Connection getConnection() throws SQLException {
        return connection;
    }

    public void close() throws SQLException {
        if (!this.closed) {
            if (stmt != null) {
                stmt.close();
            }
            connection.unregisterStatement(this);
            this.closed = true;
        }
    }

    public void addBatch(String sql) throws SQLException {
        checkOpen();

        try {
            stmt.addBatch(sql);
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public void cancel() throws SQLException {
        checkOpen();

        try {
            stmt.cancel();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public void clearBatch() throws SQLException {
        checkOpen();

        try {
            stmt.clearBatch();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public void clearWarnings() throws SQLException {
        checkOpen();

        try {
            stmt.clearWarnings();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public void closeOnCompletion() throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public int[] executeBatch() throws SQLException {
        checkOpen();

        try {
            return stmt.executeBatch();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public long[] executeLargeBatch() throws SQLException {
        throw new SQLException("Operation not support");
    }

    public long executeLargeUpdate(String sql) throws SQLException {
        throw new SQLException("Operation not support");
    }

    public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        throw new SQLException("Operation not support");
    }

    public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException {
        throw new SQLException("Operation not support");
    }

    public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException {
        throw new SQLException("Operation not support");
    }

    public int getFetchDirection() throws SQLException {
        checkOpen();

        try {
            return stmt.getFetchDirection();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int getFetchSize() throws SQLException {
        checkOpen();

        try {
            return stmt.getFetchSize();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public ResultSet getGeneratedKeys() throws SQLException {
        checkOpen();

        try {
            return stmt.getGeneratedKeys();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public long getLargeMaxRows() throws SQLException {
        throw new SQLException("Operation not support");
    }

    public long getLargeUpdateCount() throws SQLException {
        throw new SQLException("Operation not support");
    }

    public int getMaxFieldSize() throws SQLException {
        checkOpen();

        try {
            return stmt.getMaxFieldSize();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int getMaxRows() throws SQLException {
        checkOpen();

        try {
            return stmt.getMaxRows();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public boolean getMoreResults() throws SQLException {
        checkOpen();

        try {
            return stmt.getMoreResults();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public boolean getMoreResults(int current) throws SQLException {
        checkOpen();

        try {
            return stmt.getMoreResults(current);
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int getQueryTimeout() throws SQLException {
        checkOpen();

        try {
            return stmt.getQueryTimeout();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public ResultSet getResultSet() throws SQLException {
        checkOpen();

        try {
            return stmt.getResultSet();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int getResultSetConcurrency() throws SQLException {
        checkOpen();

        try {
            return stmt.getResultSetConcurrency();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int getResultSetHoldability() throws SQLException {
        checkOpen();

        try {
            return stmt.getResultSetHoldability();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int getResultSetType() throws SQLException {
        checkOpen();

        try {
            return stmt.getResultSetType();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public int getUpdateCount() throws SQLException {
        checkOpen();

        try {
            return stmt.getUpdateCount();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public SQLWarning getWarnings() throws SQLException {
        checkOpen();

        try {
            return stmt.getWarnings();
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public boolean isClosed() throws SQLException {
        return closed;
    }

    public boolean isCloseOnCompletion() throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public boolean isPoolable() throws SQLException {
        throw new SQLException("Operation Not Support!");
    }

    public void setCursorName(String name) throws SQLException {
        checkOpen();

        try {
            stmt.setCursorName(name);
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public void setEscapeProcessing(boolean enable) throws SQLException {
        checkOpen();

        try {
            stmt.setEscapeProcessing(enable);
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public void setFetchDirection(int direction) throws SQLException {
        checkOpen();

        try {
            stmt.setFetchDirection(direction);
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public void setFetchSize(int rows) throws SQLException {
        checkOpen();

        try {
            stmt.setFetchSize(rows);
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public void setLargeMaxRows(long max) throws SQLException {
        throw new SQLException("Operation Not Support!");
    }

    public void setMaxFieldSize(int max) throws SQLException {
        checkOpen();

        try {
            stmt.setMaxFieldSize(max);
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public void setMaxRows(int max) throws SQLException {
        checkOpen();

        try {
            stmt.setMaxRows(max);
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public void setPoolable(boolean poolable) throws SQLException {
        throw new SQLException("Operation Not Support!");
    }

    public void setQueryTimeout(int seconds) throws SQLException {
        checkOpen();

        try {
            stmt.setQueryTimeout(seconds);
        } catch (Throwable t) {
            throw connection.errorWrapper(t);
        }
    }

    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return false;
    }

    public <T> T unwrap(Class<T> iface) throws SQLException {
        return null;
    }

    private static final String BEGIN = "begin";
    private static final String START_TRANSACTION = "start transaction";
    private static final String START = "start";
    private static final String COMMIT = "commit";
    private static final String ROLLBACK = "rollback";

    public static boolean startTransaction(String sql) {
        if (isBlank(sql)) {
            return false;
        }

        sql = delExtraSpace(sql);

        return equalsIgnoreCase(sql, BEGIN) || equalsIgnoreCase(sql, START_TRANSACTION);
    }

    public static boolean endTransaction(String sql) {
        if (isBlank(sql)) {
            return false;
        }

        sql = delExtraSpace(sql);

        return equalsIgnoreCase(sql, COMMIT) || equalsIgnoreCase(sql, ROLLBACK);
    }

    private static String delExtraSpace(String sql) {
        sql = sql.trim();
        int length = sql.length();
        if (length > 5) {
            String prefix = sql.substring(0, 5);
            if (prefix.equalsIgnoreCase(START)) {
                sql = sql.replaceAll(" +"," ");
            }
        }
        return sql;
    }

    public static boolean isBlank(String str) {
        int strLen;
        if (str == null || (strLen = str.length()) == 0) {
            return true;
        }
        for (int i = 0; i < strLen; i++) {
            if ((!Character.isWhitespace(str.charAt(i)))) {
                return false;
            }
        }
        return true;
    }

    public static boolean equalsIgnoreCase(String str1, String str2) {
        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);
    }
}
